
const 
  gulp = require('gulp'),
  liveAlertBP = require("live-alert-bp"),
  liveAlertFormatterSass = require("live-alert-bp-formatter-sass"),
  liveAlertFormatterESlint = require("live-alert-bp-formatter-eslint"),
  liveAlertFormatterStylelint = require("live-alert-bp-formatter-stylelint"),
  plumber = require('gulp-plumber'),
  bro = require('gulp-bro'),
  babelify = require('babelify'),
  eslint = require('gulp-eslint'),
  htmlmin = require('gulp-htmlmin'),
  gulpSass = require('gulp-sass')(require('sass')),
  postcss = require('gulp-postcss'),
  cssnano = require('cssnano'),
  stylelint = require('gulp-stylelint'),
  autoprefixer = require('gulp-autoprefixer'),
  webServer = require('./web-server');  

const 
  liveAlert = new liveAlertBP({host: '127.0.0.1', port: '8080'}),
  liveAlertMessages = {
    ESLint: []
  };

const 
  jsESlint = 'src/**/*.js';

const 
  jsWatch = 'src/**/*.js',
  jsSrc = ['src/index.js'],
  jsDest = 'build';

const 
  htmlWatch = 'src/**/*.html',
  htmlSrc = ['src/templates/**/*.html'],
  htmlDest = 'build/templates';

const 
  htmlIndexWatch = 'src/index.html',
  htmlIndexSrc = ['src/index.html'],
  htmlIndexDest = './';

const 
  cssWatch = 'src/styles/**/*.scss',
  cssSrc = ['src/styles/**/*.scss'],
  cssDest = 'build/styles';


function esLint() {
  return gulp.src(jsESlint)
  .pipe(plumber({errorHandler: onError}))       
  .pipe(eslint())
  .pipe(eslint.format())
  .pipe(eslint.format(formatter_ESLint))
  .pipe(eslint.failAfterError());
}


function js() {
  process.env.NODE_ENV = 'production'
  return gulp.src(jsSrc)   
    .pipe(plumber()) 
    .pipe(bro({
        transform: [
          babelify.configure({  presets: ['@babel/env'] }),
          ['browserify-postcss', 
            {  
              plugin: ['postcss-import'] 
            }
          ],
          ['loose-envify'],
          ['blissify']
        ],
        error: onErrorBro
      })
    )    
    .pipe(gulp.dest(jsDest));
}


function html() {
  return gulp.src(htmlSrc)    
  .pipe(plumber())
  .pipe(htmlmin({
    collapseWhitespace: true,
    removeComments: true,
    removeScriptTypeAttributes: true, //Remove type="text/javascript" from script tags. Other type attribute values are left intact
    includeAutoGeneratedTags: false,
    ignoreCustomComments: [ // ignore noindex comments
        /^noindex/,
        /\/noindex+$/
    ], 
    minifyJS: false,
    minifyCSS: false,
    trimCustomFragments: true, //Удаляет пустой пространство около игнорируемых элементов
    //ignoreCustomFragments: [ (/\{\%[^\%]*?\%\}(\s)?/g) ], // Игнорирования тега
  }))
  .pipe(gulp.dest(htmlDest));
}


function htmlIndex() {
  return gulp.src(htmlIndexSrc)    
  .pipe(plumber())
  .pipe(htmlmin({
    collapseWhitespace: true,
    removeComments: true,
    removeScriptTypeAttributes: true, //Remove type="text/javascript" from script tags. Other type attribute values are left intact
    includeAutoGeneratedTags: false,
    ignoreCustomComments: [ // ignore noindex comments
        /^noindex/,
        /\/noindex+$/
    ], 
    minifyJS: false,
    minifyCSS: false,
    trimCustomFragments: true, //Удаляет пустой пространство около игнорируемых элементов
    //ignoreCustomFragments: [ (/\{\%[^\%]*?\%\}(\s)?/g) ], // Игнорирования тега
  }))
  .pipe(gulp.dest(htmlIndexDest));
}


function css() {
  return gulp.src(cssSrc)
    .pipe(plumber({errorHandler: onError}))
    .pipe(stylelint({
      customSyntax: 'postcss-scss',
      failAfterError: true,
      fix: false,
      reporters: [
        { formatter: formatterStylelint },
        { formatter: 'string', console: true }
      ]
    }))             
    .pipe(gulpSass().on('error', gulpSass.logError))   
    .pipe(postcss([
        cssnano({zindex: false, reduceIdents: false})
    ]))     
    .pipe(gulp.dest(cssDest));
}


function alert(ok){
  if(liveAlertMessages.ESLint.length > 0){
    const 
      userStyle = {}, 
      filter = []; // ['warning']
    
    liveAlert.open(
      //liveAlertFormatterESlint(liveAlertMessages.ESLint, userStyle, filter)
      liveAlertFormatterESlint(liveAlertMessages.ESLint)
    );
  }

  liveAlert.close();
  liveAlert.reloadNotification();
  liveAlert.resetError();

  liveAlertMessages.ESLint = [];

  ok();
}


function onError(err){
  if(liveAlert.hasError() === false){
    if(err.plugin === 'gulp-sass'){
      liveAlert.open(
        liveAlertFormatterSass(err)
      );
    }
  }

  this.emit('end');
}


function onErrorBro(err){
  if(liveAlert.hasError() === false){
    liveAlert.open([
      { 
        label: {
          style: { 
            backgroundColor: '#ff0000', 
            color: '#ffffff' 
          }, 
          name: 'Error'          
        }, 
        message:  '<br>'
          + '<span style="opacity: 0.5;">Reason:</span> ' + err.message + '<br>'
      }
    ]);

    console.error(err.message);
  }
}


function formatter_ESLint(messages){
  liveAlertMessages.ESLint = liveAlertMessages.ESLint.concat(messages);
}


function formatterStylelint(results, returnValue) {
  if(liveAlert.hasError() === false){
    liveAlert.open(
      liveAlertFormatterStylelint(results)
    ); 
  }

  return results;
}


function watch(){
  liveAlert.run();
  webServer();

  gulp.watch(jsWatch, gulp.series(esLint, js, alert));
  gulp.watch(htmlWatch, gulp.series(html, js, alert));
  gulp.watch(cssWatch, gulp.series(css, js, alert));
}


exports.esLint = esLint;
exports.js = js;
exports.html = html;
exports.css = css;
exports.watch = watch;
exports.alert = alert;
exports.start = gulp.series(css, html, htmlIndex, esLint, js, alert, watch);
